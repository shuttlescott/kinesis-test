// Code generated by entc, DO NOT EDIT.

package ent

import (
	"creative-production/ent/card"
	"creative-production/ent/player"
	"creative-production/ent/predicate"
	"fmt"
	"time"
)

// CardWhereInput represents a where input for filtering Card queries.
type CardWhereInput struct {
	Not *CardWhereInput   `json:"not,omitempty"`
	Or  []*CardWhereInput `json:"or,omitempty"`
	And []*CardWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "suit" field predicates.
	Suit      *card.Suit  `json:"suit,omitempty"`
	SuitNEQ   *card.Suit  `json:"suitNEQ,omitempty"`
	SuitIn    []card.Suit `json:"suitIn,omitempty"`
	SuitNotIn []card.Suit `json:"suitNotIn,omitempty"`

	// "value" field predicates.
	Value      *int  `json:"value,omitempty"`
	ValueNEQ   *int  `json:"valueNEQ,omitempty"`
	ValueIn    []int `json:"valueIn,omitempty"`
	ValueNotIn []int `json:"valueNotIn,omitempty"`
	ValueGT    *int  `json:"valueGT,omitempty"`
	ValueGTE   *int  `json:"valueGTE,omitempty"`
	ValueLT    *int  `json:"valueLT,omitempty"`
	ValueLTE   *int  `json:"valueLTE,omitempty"`

	// "player" edge predicates.
	HasPlayer     *bool               `json:"hasPlayer,omitempty"`
	HasPlayerWith []*PlayerWhereInput `json:"hasPlayerWith,omitempty"`
}

// Filter applies the CardWhereInput filter on the CardQuery builder.
func (i *CardWhereInput) Filter(q *CardQuery) (*CardQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering cards.
// An error is returned if the input is empty or invalid.
func (i *CardWhereInput) P() (predicate.Card, error) {
	var predicates []predicate.Card
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, card.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Card, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, card.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Card, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, card.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, card.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, card.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, card.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, card.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, card.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, card.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, card.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, card.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, card.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, card.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, card.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, card.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, card.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, card.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, card.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, card.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, card.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, card.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, card.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, card.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, card.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, card.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, card.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, card.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Suit != nil {
		predicates = append(predicates, card.SuitEQ(*i.Suit))
	}
	if i.SuitNEQ != nil {
		predicates = append(predicates, card.SuitNEQ(*i.SuitNEQ))
	}
	if len(i.SuitIn) > 0 {
		predicates = append(predicates, card.SuitIn(i.SuitIn...))
	}
	if len(i.SuitNotIn) > 0 {
		predicates = append(predicates, card.SuitNotIn(i.SuitNotIn...))
	}
	if i.Value != nil {
		predicates = append(predicates, card.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, card.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, card.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, card.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, card.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, card.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, card.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, card.ValueLTE(*i.ValueLTE))
	}

	if i.HasPlayer != nil {
		p := card.HasPlayer()
		if !*i.HasPlayer {
			p = card.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPlayerWith) > 0 {
		with := make([]predicate.Player, 0, len(i.HasPlayerWith))
		for _, w := range i.HasPlayerWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, card.HasPlayerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("creative-production/ent: empty predicate CardWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return card.And(predicates...), nil
	}
}

// PlayerWhereInput represents a where input for filtering Player queries.
type PlayerWhereInput struct {
	Not *PlayerWhereInput   `json:"not,omitempty"`
	Or  []*PlayerWhereInput `json:"or,omitempty"`
	And []*PlayerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "age" field predicates.
	Age      *int  `json:"age,omitempty"`
	AgeNEQ   *int  `json:"ageNEQ,omitempty"`
	AgeIn    []int `json:"ageIn,omitempty"`
	AgeNotIn []int `json:"ageNotIn,omitempty"`
	AgeGT    *int  `json:"ageGT,omitempty"`
	AgeGTE   *int  `json:"ageGTE,omitempty"`
	AgeLT    *int  `json:"ageLT,omitempty"`
	AgeLTE   *int  `json:"ageLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "score" field predicates.
	Score      *int  `json:"score,omitempty"`
	ScoreNEQ   *int  `json:"scoreNEQ,omitempty"`
	ScoreIn    []int `json:"scoreIn,omitempty"`
	ScoreNotIn []int `json:"scoreNotIn,omitempty"`
	ScoreGT    *int  `json:"scoreGT,omitempty"`
	ScoreGTE   *int  `json:"scoreGTE,omitempty"`
	ScoreLT    *int  `json:"scoreLT,omitempty"`
	ScoreLTE   *int  `json:"scoreLTE,omitempty"`

	// "cards" edge predicates.
	HasCards     *bool             `json:"hasCards,omitempty"`
	HasCardsWith []*CardWhereInput `json:"hasCardsWith,omitempty"`
}

// Filter applies the PlayerWhereInput filter on the PlayerQuery builder.
func (i *PlayerWhereInput) Filter(q *PlayerQuery) (*PlayerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering players.
// An error is returned if the input is empty or invalid.
func (i *PlayerWhereInput) P() (predicate.Player, error) {
	var predicates []predicate.Player
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, player.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Player, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, player.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Player, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, player.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, player.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, player.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, player.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, player.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, player.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, player.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, player.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, player.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, player.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, player.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, player.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, player.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, player.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, player.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, player.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, player.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, player.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, player.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, player.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, player.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, player.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, player.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, player.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, player.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Age != nil {
		predicates = append(predicates, player.AgeEQ(*i.Age))
	}
	if i.AgeNEQ != nil {
		predicates = append(predicates, player.AgeNEQ(*i.AgeNEQ))
	}
	if len(i.AgeIn) > 0 {
		predicates = append(predicates, player.AgeIn(i.AgeIn...))
	}
	if len(i.AgeNotIn) > 0 {
		predicates = append(predicates, player.AgeNotIn(i.AgeNotIn...))
	}
	if i.AgeGT != nil {
		predicates = append(predicates, player.AgeGT(*i.AgeGT))
	}
	if i.AgeGTE != nil {
		predicates = append(predicates, player.AgeGTE(*i.AgeGTE))
	}
	if i.AgeLT != nil {
		predicates = append(predicates, player.AgeLT(*i.AgeLT))
	}
	if i.AgeLTE != nil {
		predicates = append(predicates, player.AgeLTE(*i.AgeLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, player.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, player.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, player.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, player.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, player.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, player.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, player.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, player.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, player.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, player.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, player.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, player.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, player.NameContainsFold(*i.NameContainsFold))
	}
	if i.Score != nil {
		predicates = append(predicates, player.ScoreEQ(*i.Score))
	}
	if i.ScoreNEQ != nil {
		predicates = append(predicates, player.ScoreNEQ(*i.ScoreNEQ))
	}
	if len(i.ScoreIn) > 0 {
		predicates = append(predicates, player.ScoreIn(i.ScoreIn...))
	}
	if len(i.ScoreNotIn) > 0 {
		predicates = append(predicates, player.ScoreNotIn(i.ScoreNotIn...))
	}
	if i.ScoreGT != nil {
		predicates = append(predicates, player.ScoreGT(*i.ScoreGT))
	}
	if i.ScoreGTE != nil {
		predicates = append(predicates, player.ScoreGTE(*i.ScoreGTE))
	}
	if i.ScoreLT != nil {
		predicates = append(predicates, player.ScoreLT(*i.ScoreLT))
	}
	if i.ScoreLTE != nil {
		predicates = append(predicates, player.ScoreLTE(*i.ScoreLTE))
	}

	if i.HasCards != nil {
		p := player.HasCards()
		if !*i.HasCards {
			p = player.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCardsWith) > 0 {
		with := make([]predicate.Card, 0, len(i.HasCardsWith))
		for _, w := range i.HasCardsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, player.HasCardsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("creative-production/ent: empty predicate PlayerWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return player.And(predicates...), nil
	}
}
